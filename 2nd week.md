# 第二周学习总结

### 一. 函数定义

**函数定义方式**

 通过函数声明的形式来定义；
 通过函数表达式的形式来定义；
 通过Function构造函数实例化的形式来定义
 
 **Function 构造函数**
 
 可以传入任意数量的实参；
 最后一个实参为函数体；
函数体中 javascript 语句之间分号隔开；
Function 构造函数创建一个匿名函数

**arguments与形参的“双向绑定”特性**

向函数传递参数时，arguments 数组中的对应单元会和命名参数建立关联（linkage）以得到相同的值。相反，不传递参数就不会建立关联。

**arguments 的 length 属性**

每个函数都有一个 arguments 关键字，表示执行函数调用时实际传入的参数的集合，即函数的实参集合。
 在调用时，实参个数确定，arguments.length确定， 不会再发生改变。
 
 **this关键字**
 
 >1.在 function 内部被创建
 2.指向调用时所在函数所绑定的对象
 3.this 不能被赋值，但可以被 call/apply/bind  改变
 
在 JavaScript中，this是动态绑定，或称为运行期绑定的。由于其运行期绑定的特性，JavaScript中的 this 含义很丰富，它可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式。

###二. 函数对象中方法###

函数是对象，对象是一系列属性和方法的集合。

**方法**

>this 通常是被自动赋值的，但是我们可以改变this 的指向，JavaScript给我们提供了3种函数方法来改变 this 的指向。

>call、apply、bind 
 toString、valueOf

**属性**

>name、length
prototype、_ proto_

**call方法**

call( ) 方法调用一个函数, 其具有一个指定的 this 值和分别地提供的参数(参数列表)————fn.call(thisObj,arg1,arg2,...)

 thisObj: 将函数对象中的 this 指向 thisObj 对象
 
>如果未传递，this 指向全局对象 window
如果传递为 undefined/null，this 指向全局对象 window
如果传递为原始值(数字，字符串，布尔值)，this 指向该原始值的包装对象arg1,arg2,...

**apply方法**

apply() 方法调用一个函数, 其具有一个指定的 this 值和作为数组提供的参数(参数数组) ———— fn.apply(thisObj,[arg1,arg2,...])

 thisObj: 将函数对象中的 this 指向 thisObj 对象
 
>如果未传递，this 指向全局对象 window
如果传递为 undefined/null，this 指向全局对象 window
如果传递为原始值(数字，字符串，布尔值)，this 指向该原始值的包装对象arg1,arg2,...

**bind方法**

bind() 方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项 —— fn.bind(thisObj,arg1,arg2,...)

 返回值：返回一个原函数的拷贝，并拥有指定的this值和初始参数。
 
 **tostring、valueOf**
 fn.toString() 方法返回一个表示当前函数源代码的字符串。
 
 fn.valueOf() 方法返回函数本身
 
###三. 函数对象的属性及调用

**name、length**

 fn.name 属性返回函数的名称
 
 fn.length 属性指明函数的形参个数（arguments.length 是函数被调用时实参个数）

**prototype / __proto__**

每个函数都有一个 prototype 属性，指向一个对象。

每个对象实例都有一个_ proto_属性，指向它的原型对象。
 
**函数的调用**

函数调用形式（4种）

 >作为函数直接调用
 作为对象方法调用
 作为构造函数调用
 通过call/apply间接调用
 
###四. 执行上下文

**执行上下文（execution context）**

 函数每调用一次，就会创建一个新的执行上下文
 函数执行结束，相应的执行上下文销毁
 
 **执行上下文栈（Execution context stack，ECS）**
 
 执行上下文栈按照函数的调用顺序来管理执行上下文
 栈底永远是全局上下文，栈顶是当前正在执行的函数
 
 **调用栈（Call Stack）**
 
 代码执行时JavaScript 引擎会以栈的方式来处理和追踪函数调用
 
 栈底对应的是全局上下文环境，而栈顶对应的是当前正在执行的上下文环境
 
 **return语句作用**
 
 返回值
 
 终止函数的执行
 
 **生命周期**
 
##### 执行上下文的生命周期
1.创建阶段
2.创建变量对象
3.确定作用域链
4.确定this指向

##### 执行阶段

1.变量赋值
2.函数引用
3.执行代码
 
 **变量对象**
 
 函数的所有形参
 当前上下文中的所有函数声明
 当前上下文中所有变量声明
 
 **预编译**
 JavaScript代码的整个执行过程
 （JavaScript 引擎是一段一段地运行代码的执行每一段代码之前，都有一个“预编译”）
 
 JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段
 编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。
 执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。
 
 **声明提升**
 
 JavaScript 引擎把所有的变量声明和函数声明提升到当前作用域的最前面
 
 规则1：函数声明整体提前（注意：函数表达式）
 规则2：变量声明提前，赋值留在原地
 规则3：函数会首先被提升，然后才是变量（注意：重复的var声明会被忽略，函数声明可以覆盖前面的）
 
 **作用域**
 
 作用域就是变量与函数的可访问范围
 作用域控制着变量与函数的可见性和生命周期
 
 >几乎所有的编程语言最基本的功能之一，就是能够储存变量当中的值，并且能在之后对这个值进行访问和修改。

 >变量储存在哪里以及程序需要时如何找到他们，这些问题说明需要一套设计良好的规则来存储变量，并且之后可以方便地找到这些变量。这套规则称为作用域。
 
 >作用域这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。
 
 **作用域类型**
 
 全局作用域（global scope）
 
 函数作用域（function scope）
 
 块作用域（block scope）
ES5 没有块作用域，在 ES6 中添加了块作用域
任何一对花括号 { } 中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域

**作用域模型**

作用域共有两种主要的工作模型

 词法作用域（静态性）
 是由变量和函数定义的书写位置决定的，与调用位置无关
 
 动态作用域（动态性）
由调用位置决定，不关心变量和函数的定义的书写位置

**[[scope]]属性**

虚拟属性，无法访问和修改
函数创建（定义）时生成的属性，保存着这个函数的父作用域的作用域链。

**作用域链**

由当前执行环境与上层（父级）执行环境的一系列变量对象组成
提供对变量和函数访问的权限和顺序的规则
>任何执行上下文时刻的作用域，都是由作用域链 (scope chain) 来实现。 在一个函数被定义的时候，会将它定义时候的 scope chain 链接到这个函数对象的[[scope]]属性。 在一个函数对象被调用的时候，会创建一个活动对象 (也就是一个对象，然后对于每一个函数的形参，都命名为该活动对象的命名属性，然后将这个活动对象做为此时的作用域链 (scope chain) 最前端， 并将这个函数对象的 [[scope]] 加入到 scope chain 中

**作用域链与执行上下文**

执行时，当前执行上下文，对应一个作用域链环境来管理和解析变量和函数（动态性）
变量查找按照由内到外的顺序（遵循词法作用域），直到完成查找，若未查询到则报错
当函数执行结束，运行期上下文被销毁，此作用域链环境也随之被释放

**变量的管理**

>当程序运行到变量所在的作用域时，变量被创建，此时需要一个存储的空间
JS中提供存储空间的数据结构被称为环境，每个函数都有自己的执行环境
每个执行环境都有一个与之关联的变量对象，环境中所有变量和函数都保存在此对象中
Web浏览器中，全局执行环境为window对象

**作用域链（在 ECMA262 中的解释，涉及到内部属性）**

任何执行上下文时刻的作用域，都是由作用域链 (scope chain) 来实现。 在一个函数被定义的时候，会将它定义时候的 scope chain 链接到这个函数对象的[[scope]]属性。在一个函数对象被调用的时候，会创建一个活动对象 (也就是一个对象，然后对于每一个函数的形参，都命名为该活动对象的命名属性，然后将这个活动对象做为此时的作用域链 (scope chain) 最前端，并将这个函数对象的 [[scope]] 加入到 scope chain 中

###五. 闭包

**LHS/RHS**

LHS

>当变量出现在赋值操作的左侧时进行 LHS 查询
 其赋值操作的目标是谁，不关心它的当前值
 
 RHS
 
 >当变量出现在赋值操作的右侧时进行 RHS 查询
 其取到它的源值，这意味着得到某某变量的值
 
 **闭包**
 
 执行上下文（代号A）
 在执行上下文中创建的函数（代号B）
 当B（函数）执行时，如果访问了A中变量对象中的值，就会产生闭包
 
 闭包是由函数和其相关的引用环境组合而成的实体
 闭包是词法作用域中的函数和其相关变量的包裹体
 
 **闭包的作用**
 
 可通过闭包访问隐藏在函数作用域内的局部变量
 使函数中的变量被保存在内存中不被释放

 **闭包与作用域链**
 
 作用域规则在代码编译阶段确定，即在代码书写之后作用域链就已确定
 作用域链在代码执行时生成
 变量查找按照作用域链由内到外的顺序（遵循词法作用域），直到完成查  找，若未查询到则报错
 调用栈在代码执行时确定，作用是处理和追踪函数调用
 
 **垃圾回收机制**
 
 1.执行上下文（execution context）
 函数每调用一次，就会创建一个新的执行上下文
 函数执行结束，相应的执行上下文销毁
 2.闭包：使函数中的变量被保存在内存中不被释放
 
 内存声明周期
 >分配内存
 使用内存
 释放内存
 
 垃圾回收方法
 >引用计数
 标记-—清除
 
 **IIFE**
 
 立即执行的函数表达式
 立即执行函数也能返回值并且可以赋值给其它变量
 立即执行函数只能执行一次，而命名的函数可重复调用
 
 



 


