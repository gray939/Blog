# 第四周学习总结

### 一 .原型与原型链

**prototype/constructor**

只有函数才会有 prototype 属性，它引用了一个对象；
只要创建一个新函数，JS引擎会根据一组特定的规则为该函数创建一个 prototype 对象

prototype 对象初始化时有一个属性constructor，用来引用函数

**__proto__**

任何对象都有__proto__属性，指向构造函数的prototype 对象

**原型继承**

实例继承原型的属性，可以访问这个属性，就像本身拥有该属性一样

**属性访问机制**

当通过对象访问属性时，JavaScript首先从本对象查找，接着是它的原型，以及原型的原型。即按照原型链查找属性

**属性屏蔽**

当在本对象和原型对象具有相同的属性时，不会再去原型上访问。也就是说本对象“遮蔽”或者“隐藏”了原型对象中的属性

**覆写**

一个对象的属性可以覆写原型对象相同键的属性。此时，前者的属性最被找到，可以隐藏原型对象的属性，使得原型对象的属性不能被访问

**属性分类**

自有属性

>自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性

obj.hasOwnProperty(prop) 
 返回一个布尔值，指示对象自身属性中是否具有指定的属性
 prop —— 要检测的属性字符串名 
 
 Object.getOwnPropertyNames(obj)
 返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组

继承属性

>从原型链上查找的属性

**遍历属性**

Object.getOwnPropertyNames(obj)
返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组
 		
Object.keys(obj)
返回一个由指定对象的所有自身属性的属性名（不包括不可枚举属性）组成的数组

for in 循环
遍历一个对象的所有可枚举属性键

**检测属性**

obj.hasOwnProperty(prop) 

prop  in  obj
obj —— 检查它（或其原型链）是否包含具有指定名称的属性的对象;
如果指定的属性在指定的对象或其原型链中，则in运算符返回 true

**原型链**

JavaScript 基于原型的语言 (prototype-based language)

>每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链;
解释了为何一个对象会拥有定义在其他对象中的属性和方法


>每个实例对象（object ）都有一个属性（__proto__）指向它的原型对象（prototype）。该原型对象也有一个自己的原型对象(__proto__) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。
 可通过实例化出来的对象的__proto__属性来确认原型
 
 所有对象具有 __ proto__ 属性
 函数具有 prototype属性，Function.prototype是例外，虽然是函数，但是不具有 prototype 属性
 函数具有prototype、__ proto__属性
 
 Function created by Function
 Function.__ proto__==Function.prototype
 
 Object created  by Function
 Object.__ proto__==Function.prototype
 
 Function.prototype.__ proto__ == Object.prototype
 给 Object.prototype 添加方法和属性，Function.prototype也会拥有相同的方法和属性，相反则不具有
 
 Function.prototype 是函数的起源，Object.prototype 是对象的起源
 函数也是对象，是对象中的一等公民
 
 **获取/设置/判断原型对象**
 
 Object.getPrototypeOf(obj) 
 返回指定对象的原型，如果没有继承属性，则返回 null
 
 Object.create(proto)
 创建一个新对象，使用现有的对象来提供新创建的对象的__ proto__
 
 prototypeObj.isPrototypeOf(object)
 测试 prototypeObj 对象是否存在 object 对象的原型链上
 
 **数据类型检测**
 
 1. typeof
 
 2. constructor

(1).对象的 constructor 属性用于返回创建该对象的函数，也就是我们常说的构造函数。例如：Array、Boolean、Date、Function、Number、Object、String

(2). 在 JavaScript 中，通过构造函数创建的实例对象可以访问原型对象的constructor 属性

3. object instanceof constructor

测试 constructor构造函数的prototype对象是否出现在object对象的原型链中的任何位置;

 object —— 要检测的对象
 constructor —— 某个构造函数
 
 4. toString

toString 是 Object 原型对象上的方法，使用 call 来调用该方法会返回调用者的类型字符串，格式为 [object,xxx]，xxx 是调用者的数据类型

 包括：String、Number、Boolean、Undefined、Null、Function、Date、Array、RegExp、Error、HTMLDocument 等， 基本上，所有的数据类型都可以通过这个方法获取到
 
 需要注意的是，必须通过 call 或 apply 来调用，而不能直接调用 toString ， 从原型链的角度讲，所有对象的原型链最终都指向了 Object， 按照JavaScript 属性访问规则，其他对象应该也可以直接访问到 Object 的 toString 方法，而事实上，大部分的对象都实现了自身的 toString 方法，这样就可能会导致 Object 的 toString 被终止查找，因此要用 call/apply 来强制调用 Object 的 toString 方法
 
### 二 .构造函数与继承

**构造函数**

 构造函数的首字母必须大写，用来区分于普通函数;
 内部使用的 this 对象，来指向即将要生成的实例对象;
 使用 New 来生成实例对象
 
 **实例化与内存**
 
 实例化即创建一个变量的过程，是将对象复制一个副本;
 然后通过构造函数来对这个占有独立空间的变量进行初始化
 
 **实例化过程**
 
 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作;
 创建（或者说构造）一个全新的对象;
 这个新对象会被执行 [[ 原型 ]] 连接;
 这个新对象会绑定到函数调用的 this;
 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回 this (新对象)
 
 **通过原型在对象间共享数据**
 
 1.所有的实例对象都可以获取构造器函数中的属性和方法。但是，同一个对象实例之间，无法共享属性
 2.所有实例都会通过原型链引用到prototype对象，prototype引用对象相当于特定类型所有实例都可以访问到的一个公共容器，我们可以把重复的东西放到公共容器
 
 **构造函数返回值**
 
构造函数没有 return，会默认返回 this，也就是新的实例对象；
如果使用了 return，且返回值为基本数据类型，构造函数会忽略 return的值，依然返回 this 对象；
如果使用了 return，且返回值为引用数据类型，构造函数会返回 return 的值

**继承**

 因为构造函数与原型的不同特性，分别解决了我们不同的困扰;
 因此当我们想要实现继承时，就必须得根据构造函数与原型的不同而采取不同的策略
 
 **构造继承**
 
 通过使用 call、apply 方法可以在新创建的对象上执行构造函数，用父类的构造函数来增加子类的实例
 
 **原型继承**
 原型的继承，则只需要将子级的原型对象设置为父级的一个实例，加入到原型链中即可
 
 **组合继承**
 利用构造继承和原型继承组合
 
 **原型式继承**
 采用原型式继承并不需要定义一个构造函数，传入参数obj，生成一个继承 obj 对象的对象
 
 **Object.create(obj)**
 方法创建一个新对象，使用现有的对象来提供新创建的对象的__ proto__
 
 **实例的方法**
 实例对象中的方法可以写在构造函数内，也可以写在构造函数prototype 属性上;
 把方法写在构造函数内的情况我们简称为函数内方法;
 把方法写在 prototype 属性上的情况我们简称为 prototype上的方法
 
 定义在构造函数内部的方法，会在它的每一个实例上都克隆这个方法;
 定义在构造函数的 prototype属性上的方法会让它的所有示例都共享这个方法，但是不会在每个实例的内部重新定义这个方法;
如果我们的应用需要创建很多新的对象，并且这些对象还有许多的方法，为了节省内存，我们建议把这些方法都定义在构造函数的 prototype 属性上

在某些情况下，我们需要将某些方法定义在构造函数中，这种情况一般是因为我们需要访问构造函数内部的私有变量

函数内方法：定义在构造函数内部的方法，会在它的每一个实例上都克隆这个方法，内存占用就比较大，但可以访问函数内部的私有变量 

 prototype上的方法：定义在构造函数的prototype属性上的方法会让它的所有示例都共享这个方法，但是不会在每个实例的内部重新定义这个方法，内存占用就比较小，但不可以访问函数内部的私有变量
 
### 三 .对象深浅拷贝

**递归**
一个方法重复调用自身的情况叫做递归;
 但是需要注意的是，一定要有一个条件来结束递归，否则将会陷入无限的循环
 
 **拷贝**
 
 浅拷贝
 1.拷贝基本类型的值;
 2.拷贝引用类型的引用（地址）
 
 >对象拷贝时，如果属性是对象或数组时，这时候我们传递的只是一个地址。因此子对象在访问该属性时，会根据地址回溯到父对象指向的堆内存中，即父子对象发生了关联，两者的属性值会指向同一内存空间
 
 
**深拷贝 = 浅拷贝 + 递归**

1.拷贝基本类型的值;
拷贝引用类型时（比如数组和或对象），使用递归，把父对象中所有属于引用类型的对象都遍历赋给子对象即可

 浅拷贝： 将原对象或原数组的引用直接赋给新对象的属性，新对象／数组的属性只是原对象属性的一个引用
 深拷贝： 创建一个新的对象和数组，将原对象的各项属性的“值”拷贝过来，是“值”而不是“引用”
 深拷贝和浅拷贝最根本的区别在于是否是真正获取了一个对象的复制实体，而不是引用
